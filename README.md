# Thirdtool-backend-re-


# 🧠 The Third Tool

> **망각 방지를 위한 세 번째 도구**  
> 연필과 공책 그다음, 기억을 완성하는 우리의 도구

---

## 🗓 프로젝트 개요

- **프로젝트명:** The Third Tool
- **부제:** 망각 방지를 위한 3번째 도구 (연필, 공책 그리고 The Third Tool)
- **진행 기간:** 작성 중
- **팀원:**
  - **Frontend:** 김초연, 황영준
  - **Backend:** 김준성, 이성혁

---

## 🔍 한 줄 소개

우리는 방대한 데이터 속에서도 잊지 않도록 돕는 **망각 방지 백신(tool)**을 개발합니다.

---

## 📌 필요성 및 배경

- 현대 사회에서 데이터의 양은 기하급수적으로 증가하고 있으며, 단순한 공책 정리나 기존 메모 서비스만으로는 이를 **효과적으로 학습하고 오래 기억하기 어렵다**고 판단했습니다.
- 우리는 기억할 것이 늘어나는 환경에서 살고 있으며, 개인이 정보를 **효율적으로 이해하고 자연스럽게 받아들일 수 있는 강력한 도구**가 필요합니다.
- AI 시대와 플랫폼 경제 속에서 데이터 활용 방식이 급변하고 있지만, 이에 대응하는 **기억 보조 시스템은 아직 부족**한 실정입니다.
- 컴퓨터의 메모리 관리 방식처럼 **기억도 체계적으로 정리된다면** 학습의 효율이 높아질 것이라는 인식에서 시작되었습니다.

---

## 🎯 핵심 컨셉

### 📌 The Third Tool

기존에는 연필과 공책이 학습의 기본 도구였다면, 그 다음 단계에서 **효율적인 암기를 지원하는 도구(third tool)**로 자리 잡는 것이 핵심입니다.

### 📍 컨셉 방향

- 유튜브에서 반복 추천되는 영상처럼 **정보가 주기적으로 노출**되면, 억지로 외우지 않아도 **자연스럽게 체화**되는 경험이 가능합니다.
- **암기를 강요하지 않는 환경**, 그러나 반복적인 추천을 통해 기억을 유도하는 환경을 목표로 합니다.
- **망각을 줄이고, 암기를 극대화**하는 요소를 분석하여 설계합니다.
- 다양한 학습 방식에 맞춰 **지속적으로 튜닝 및 개선**되는 시스템을 목표로 합니다.

---

## 🧩 개발 기능 구성

### 📷 포토 카드 시스템 – 주기 학습 관리

- 사용자가 업로드한 **책 이미지**를 기반으로 **중요 부분을 가려 암기 카드로 전환**할 수 있습니다.
- **가린 영역을 클릭**하여 정답 확인 가능하며, 사용자의 반응을 바탕으로 복습 주기를 조절합니다.
- **쉬운 내용은 자동 삭제**, 어려운 내용은 반복 노출되는 **스마트 학습 시스템** 도입.
- **OS 캐시 알고리즘 + 망각 곡선 기반** 복습 주기 최적화 예정.

### 🔧 자체 튜닝 시스템

- 사용자가 전체 학습 흐름을 **자기 점검**하며 부족한 부분을 스스로 인지할 수 있도록 돕습니다.
- 포토카드, 덱 시스템과 연계되어 **단편적 기억 → 맥락적 이해**로 이어집니다.
- 이야기의 줄거리를 파악하듯 **지식 구조를 연결하는 흐름**을 강조합니다.

### 🗃️ 덱 시스템 (Deck System)

- 사용자는 자신만의 **학습 덱(단위)**을 구성하고, 이를 **분야별로 저장하거나 공유**할 수 있습니다.
- **멘토 기능 및 피드백 기능**을 통해 공동 학습이 가능해집니다.
- 장기적으로는 **학습 커리큘럼 시스템**까지 확장할 수 있는 구조입니다.

---

## 🎯 기대효과 및 활용방안

### ✅ 기대 효과

- **학습 효율성 극대화:**
  - 시각 기반 학습(포토카드)을 통한 집중 학습
  - 반복 노출 알고리즘을 통한 기억 강화
  - 사용자의 학습 수준에 따라 **맞춤형 반복** 제공

- **자기 주도 학습 강화:**
  - **튜닝 시스템**을 통해 자신의 이해도를 점검하고 개선
  - 반복적 복습보다는 **필요한 부분에 집중**한 학습 유도

- **커뮤니티 기반 확장:**
  - **덱 공유 및 멘토링 기능**을 통해 사용자 간 협업 가능
  - 데이터가 쌓일수록 **개인화된 학습 로드맵 제공** 가능

### 🚀 활용 방안

- **학생, 직장인, 시험 준비생 등 모든 학습자**에게 맞춤형 학습 제공
- **사진 + 텍스트 + 메모**를 통해 다양한 입력 방식 제공
- 학습 방식과 알고리즘을 지속 업데이트하며 **기억 보조 생태계**로 확장

---

## ⚙️ 기술 스택

### FE
- React.js

### BE
- Spring Boot
- Spring Security
- JPA

### DB
- MySQL

### Infra
- AWS S3 (이미지 저장)
- Docker (개발 환경 분리)

---

## 🔗 참고 서비스

- Anki
- Notion
- Speak

---

> 지금은 도입기에 불과하지만, 우리가 기록하는 모든 정보가 **기억으로 체화**되는 그날까지 The Third Tool은 계속 발전합니다.


## 👷 버전 기록

|   버전    | <div align="center">업데이트 내용</div>                                                                                     | 업데이트 날짜 |
| :-------: | :-------------------------------------------------------------------------------------------------------------------------- | :-----------: |
| `v1.0.0`  | 첫 번째 버전 오픈<br/>- 프로젝트 구조 정리<br/>- 포토카드 시스템 기획 및 개발 시작<br/>- 자체 튜닝 시스템 설계<br/>- 덱 시스템 설계 |   24.05.18   |




# thirdtool-backend
깃 관련 간단한 가이드 

우리는 각 기능 단위(Feature)로 브랜치를 생성하고, 작업 후 `main` 브랜치에 Pull Request(PR) 방식으로 병합합니다.  
아래는 개발 중 따라야 할 Git 규칙입니다.

---

## 1. 브랜치 전략

- `main`: 배포용 브랜치 (절대 직접 푸시 금지)
- `feature/기능이름`: 기능 단위 작업 브랜치  
  예: `feature/login`, `feature/user-profile`, `feature/#12-refactor-tag`

> ✅ 하나의 기능이 끝나면 해당 브랜치는 병합 후 삭제

---

## 2. 브랜치 생성 및 이동

```bash
git checkout -b feature/기능이름
```

예:
```bash
git checkout -b feature/login-api
```

---

## 3. 커밋 메시지 규칙

형식:
```
[feature-기능이름] 작업 내용
```

예:
- `[feature-login] 로그인 API 구현`
- `[feature-tag] 해시태그 서비스 로직 분리`

---

## 4. 작업 저장 및 푸시

```bash
git add .
git commit -m "[feature-기능이름] 작업 내용"
git push origin feature/기능이름
```

---

## 5. Pull Request (PR)

1. GitHub에서 `main ← feature/기능이름` 기준 PR 생성
2. 제목: `[feature-기능이름] 작업 내용`
3. 리뷰어에게 코드 리뷰 요청- 반드시 리뷰가 확인이 되었을 때만 main 브랜치에 남길 것 
4. 승인되면 `main` 브랜치에 병합

---

## 6. 충돌 해결

```bash
git pull origin main --rebase
# 충돌 파일 수정
git add .
git rebase --continue
git push -f origin feature/기능이름
```

---

## 7. 기타 규칙

- 공통 설정 파일(`QuerydslConfig`, `SecurityConfig`)은 `global/config` 폴더에 위치
- 모든 기능은 자신의 feature 브랜치에서 구현 후 병합
- 테스트 및 설정 리팩토링은 가능하면 독립된 브랜치로 작업

---

## 🧭 팀 협업 규칙 (Issue / Pull Request / Project)

### 📝 Issue 작성 규칙

이슈를 등록할 때는 아래 형식을 따라주세요:

#### 📋 Checklist
- [ ] 📁 Jira 이슈를 등록했나요?  
  예: [TNT-000](https://jira.example.com/browse/TNT-000)

#### ✅ Tasks
- [ ] 이슈 요약을 간결하게 적어주세요  
  예: 로그인 API 예외처리 추가, 마이페이지 UI 수정 등

#### 🙋🏻 More
- 참고할 내용이나, 연관 이슈/기능, 논의할 사항이 있다면 자유롭게 작성해주세요  
  예: "해당 기능은 #14 이슈와 연동되어야 합니다."

> 💡 **Project 자동화 연동을 위해, 이슈 완료 후 반드시 `Closed` 처리해주세요.**

---

### 🚀 Pull Request 작성 규칙

PR을 올릴 때는 아래 양식을 따라주세요:

#### 🔗 관련 이슈
- 관련된 Jira 또는 GitHub 이슈를 링크해주세요  
  예: `[TNT-001](https://jira.example.com/browse/TNT-001)`

#### ✨ 작업 내용
- 해당 PR에서 구현하거나 수정한 내용을 간결하게 정리해주세요  
  예: "프로필 수정 API 구현", "이메일 인증 기능 추가"

#### ✅ 체크리스트
- [ ] 코드가 정상적으로 컴파일되나요?
- [ ] 테스트 코드를 통과했나요?
- [ ] merge할 브랜치를 정확히 선택했나요? (ex: `main`, `dev`)
- [ ] Label을 지정했나요?

#### 🎃 새롭게 알게된 사항
- 작업하면서 새로 학습한 개념이나 문제 해결 경험이 있다면 적어주세요 (선택 사항)

#### 📋 참고 사항
- 리뷰어가 주의 깊게 봐야 할 부분, 배포 시 유의 사항 등을 작성해주세요  
  예: 외부 API 연동, 예외 처리 주의 등

---

### 📌 프로젝트 사용 시 주의사항

- Issue가 **Close** 상태가 되면, GitHub Project에서도 `"Done"` 칼럼으로 자동 이동됩니다.  
- 수동으로 종료할 경우에도 **반드시 `Closed` 처리**해주세요.

